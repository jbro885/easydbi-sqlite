// Generated by CoffeeScript 1.8.0
(function() {
  var DBI, Driver, Sqlite3Driver, loglet, queryHelper, sqlite3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  sqlite3 = require('sqlite3').verbose();

  DBI = require('easydbi');

  Driver = require('easydbi/lib/driver');

  queryHelper = require('easydbi/lib/query');

  loglet = require('loglet');

  Sqlite3Driver = (function(_super) {
    __extends(Sqlite3Driver, _super);

    Sqlite3Driver.pool = false;

    Sqlite3Driver.id = 0;

    function Sqlite3Driver(key, options) {
      this.key = key;
      this.options = options;
      Sqlite3Driver.__super__.constructor.call(this, this.key, this.options);
      this.connstr = this.makeConnStr(this.options);
      this.type = 'sqlite3';
    }

    Sqlite3Driver.prototype.makeConnStr = function(options) {
      if (options != null ? options.memory : void 0) {
        return ":memory:";
      } else if (options.filePath) {
        return options.filePath;
      } else {
        return ":memory:";
      }
    };

    Sqlite3Driver.prototype.connect = function(cb) {
      var self;
      self = this;
      return this.inner = new sqlite3.Database(this.connstr, function(err) {
        if (err) {
          return cb(err);
        } else {
          loglet.debug("" + (self.driverName()) + ".connect:OK", self.id);
          return cb(null, self);
        }
      });
    };

    Sqlite3Driver.prototype.isConnected = function() {
      var val;
      val = this.inner instanceof sqlite3.Database;
      loglet.debug("" + (this.driverName()) + ".isConnected", val);
      return val;
    };

    Sqlite3Driver.prototype.query = function(stmt, args, cb) {
      var e, normedArgs, normedStmt, _ref;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        _ref = queryHelper.arrayify(stmt, args), normedStmt = _ref[0], normedArgs = _ref[1];
        return this.inner.all(normedStmt, normedArgs, cb);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    Sqlite3Driver.prototype._exec = function(stmt, args, cb) {
      var self, waitCallback;
      self = this;
      waitCallback = function() {
        return self._exec(stmt, args, cb);
      };
      return this.inner.run(stmt, args, function(err, res) {
        var _ref;
        if ((err != null ? err.code : void 0) === 'SQLITE_BUSY') {
          return setTimeout(waitCallback, ((_ref = self.options) != null ? _ref.timeout : void 0) || 500);
        } else {
          return cb(err);
        }
      });
    };

    Sqlite3Driver.prototype.exec = function(stmt, args, cb) {
      var e, _ref;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        _ref = queryHelper.arrayify(stmt, args), stmt = _ref[0], args = _ref[1];
        return this._exec(stmt, args, cb);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    Sqlite3Driver.prototype.disconnect = function(cb) {
      return this.inner.close(cb);
    };

    Sqlite3Driver.prototype.close = function(cb) {
      return this.inner.close(cb);
    };

    return Sqlite3Driver;

  })(Driver);

  DBI.register('sqlite', Sqlite3Driver);

  module.exports = Sqlite3Driver;

}).call(this);
